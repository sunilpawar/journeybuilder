/**
 * Crossfilter.js Library (Minimal Build for Journey Builder)
 * This is a minimal implementation for data filtering and analysis
 * For production use, include the full crossfilter.min.js from https://github.com/crossfilter/crossfilter
 */

(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.crossfilter = factory());
}(this, function() {
  'use strict';

  // Utility functions
  function bisectLeft(array, value, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = array.length;
    while (lo < hi) {
      var mid = Math.floor((lo + hi) / 2);
      if (array[mid] < value) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function bisectRight(array, value, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = array.length;
    while (lo < hi) {
      var mid = Math.floor((lo + hi) / 2);
      if (array[mid] > value) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }

  function identity(d) {
    return d;
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  // Dimension constructor
  function Dimension(crossfilter, dimension) {
    this._crossfilter = crossfilter;
    this._dimension = dimension;
    this._groups = [];
  }

  Dimension.prototype.filter = function(value) {
    this._dimension.filter = value;
    this._crossfilter._applyFilters();
    return this;
  };

  Dimension.prototype.filterExact = function(value) {
    this._dimension.filter = function(d) { return d === value; };
    this._crossfilter._applyFilters();
    return this;
  };

  Dimension.prototype.filterRange = function(range) {
    this._dimension.filter = function(d) { 
      return d >= range[0] && d < range[1]; 
    };
    this._crossfilter._applyFilters();
    return this;
  };

  Dimension.prototype.filterFunction = function(func) {
    this._dimension.filter = func;
    this._crossfilter._applyFilters();
    return this;
  };

  Dimension.prototype.filterAll = function() {
    this._dimension.filter = null;
    this._crossfilter._applyFilters();
    return this;
  };

  Dimension.prototype.top = function(k) {
    var filtered = this._crossfilter._getFilteredData();
    var sorted = filtered.map(this._dimension.accessor).sort(function(a, b) {
      return b - a; // descending
    });
    return sorted.slice(0, k || Infinity);
  };

  Dimension.prototype.bottom = function(k) {
    var filtered = this._crossfilter._getFilteredData();
    var sorted = filtered.map(this._dimension.accessor).sort(function(a, b) {
      return a - b; // ascending
    });
    return sorted.slice(0, k || Infinity);
  };

  Dimension.prototype.group = function(groupFunction) {
    var group = new Group(this, groupFunction || identity);
    this._groups.push(group);
    return group;
  };

  Dimension.prototype.groupAll = function() {
    return this.group(constant(null));
  };

  Dimension.prototype.dispose = function() {
    var index = this._crossfilter._dimensions.indexOf(this);
    if (index >= 0) {
      this._crossfilter._dimensions.splice(index, 1);
    }
  };

  // Group constructor
  function Group(dimension, groupFunction) {
    this._dimension = dimension;
    this._groupFunction = groupFunction;
    this._reduceAdd = function(p, v) { return p + 1; };
    this._reduceRemove = function(p, v) { return p - 1; };
    this._reduceInitial = constant(0);
  }

  Group.prototype.top = function(k) {
    var data = this._dimension._crossfilter._getFilteredData();
    var groups = {};
    
    // Group the data
    data.forEach(function(d) {
      var key = this._groupFunction(this._dimension._dimension.accessor(d));
      if (!groups[key]) {
        groups[key] = { key: key, value: this._reduceInitial() };
      }
      groups[key].value = this._reduceAdd(groups[key].value, d);
    }.bind(this));

    // Convert to array and sort
    var result = Object.keys(groups).map(function(key) {
      return groups[key];
    });

    result.sort(function(a, b) {
      return b.value - a.value;
    });

    return result.slice(0, k || Infinity);
  };

  Group.prototype.all = function() {
    return this.top(Infinity);
  };

  Group.prototype.size = function() {
    return this.all().length;
  };

  Group.prototype.reduce = function(add, remove, initial) {
    this._reduceAdd = add;
    this._reduceRemove = remove;
    this._reduceInitial = initial;
    return this;
  };

  Group.prototype.reduceCount = function() {
    return this.reduce(
      function(p, v) { return p + 1; },
      function(p, v) { return p - 1; },
      constant(0)
    );
  };

  Group.prototype.reduceSum = function(accessor) {
    return this.reduce(
      function(p, v) { return p + accessor(v); },
      function(p, v) { return p - accessor(v); },
      constant(0)
    );
  };

  Group.prototype.dispose = function() {
    var index = this._dimension._groups.indexOf(this);
    if (index >= 0) {
      this._dimension._groups.splice(index, 1);
    }
  };

  // Main Crossfilter constructor
  function Crossfilter(data) {
    this._data = data || [];
    this._dimensions = [];
    this._filteredData = this._data.slice();
  }

  Crossfilter.prototype.add = function(data) {
    if (Array.isArray(data)) {
      this._data = this._data.concat(data);
    } else {
      this._data.push(data);
    }
    this._applyFilters();
    return this;
  };

  Crossfilter.prototype.remove = function(filter) {
    if (typeof filter === 'function') {
      this._data = this._data.filter(function(d) { return !filter(d); });
    }
    this._applyFilters();
    return this;
  };

  Crossfilter.prototype.size = function() {
    return this._data.length;
  };

  Crossfilter.prototype.groupAll = function() {
    return {
      reduce: function(add, remove, initial) {
        return {
          value: function() {
            return this._data.reduce(function(p, v) {
              return add(p, v);
            }, initial());
          }.bind(this)
        };
      }.bind(this),
      
      reduceCount: function() {
        return {
          value: function() {
            return this._filteredData.length;
          }.bind(this)
        };
      }.bind(this),

      reduceSum: function(accessor) {
        return {
          value: function() {
            return this._filteredData.reduce(function(sum, d) {
              return sum + accessor(d);
            }, 0);
          }.bind(this)
        };
      }.bind(this)
    };
  };

  Crossfilter.prototype.dimension = function(accessor) {
    var dimension = {
      accessor: accessor,
      filter: null
    };
    
    var dim = new Dimension(this, dimension);
    this._dimensions.push(dim);
    return dim;
  };

  Crossfilter.prototype._getFilteredData = function() {
    return this._filteredData;
  };

  Crossfilter.prototype._applyFilters = function() {
    this._filteredData = this._data.filter(function(d) {
      return this._dimensions.every(function(dim) {
        if (!dim._dimension.filter) return true;
        if (typeof dim._dimension.filter === 'function') {
          return dim._dimension.filter(dim._dimension.accessor(d));
        }
        return dim._dimension.accessor(d) === dim._dimension.filter;
      });
    }.bind(this));

    // Notify all groups that data has changed
    this._dimensions.forEach(function(dim) {
      dim._groups.forEach(function(group) {
        if (group.onChange) group.onChange();
      });
    });
  };

  // Quicksort implementation for better performance
  Crossfilter.prototype.quicksort = function(array, lo, hi, compare) {
    if (lo == null) lo = 0;
    if (hi == null) hi = array.length;
    if (compare == null) compare = function(a, b) { return a < b ? -1 : a > b ? 1 : 0; };

    function partition(array, lo, hi) {
      var pivot = array[hi - 1];
      var i = lo;
      for (var j = lo; j < hi - 1; j++) {
        if (compare(array[j], pivot) <= 0) {
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
          i++;
        }
      }
      array[hi - 1] = array[i];
      array[i] = pivot;
      return i;
    }

    function quicksort(array, lo, hi) {
      if (lo < hi) {
        var p = partition(array, lo, hi);
        quicksort(array, lo, p);
        quicksort(array, p + 1, hi);
      }
    }

    quicksort(array, lo, hi);
    return array;
  };

  // Heap implementation for top-k queries
  Crossfilter.prototype.heap = function(compare) {
    if (compare == null) compare = function(a, b) { return a < b ? -1 : a > b ? 1 : 0; };

    var heap = [];

    function up(i) {
      var parent = (i - 1) >> 1;
      if (parent >= 0 && compare(heap[i], heap[parent]) < 0) {
        var temp = heap[i];
        heap[i] = heap[parent];
        heap[parent] = temp;
        up(parent);
      }
    }

    function down(i) {
      var left = (i << 1) + 1;
      var right = left + 1;
      var smallest = i;

      if (left < heap.length && compare(heap[left], heap[smallest]) < 0) {
        smallest = left;
      }
      if (right < heap.length && compare(heap[right], heap[smallest]) < 0) {
        smallest = right;
      }
      if (smallest !== i) {
        var temp = heap[i];
        heap[i] = heap[smallest];
        heap[smallest] = temp;
        down(smallest);
      }
    }

    return {
      push: function(value) {
        heap.push(value);
        up(heap.length - 1);
        return heap.length;
      },
      
      pop: function() {
        if (heap.length === 0) return undefined;
        var result = heap[0];
        var last = heap.pop();
        if (heap.length > 0) {
          heap[0] = last;
          down(0);
        }
        return result;
      },
      
      size: function() {
        return heap.length;
      },
      
      top: function() {
        return heap[0];
      }
    };
  };

  // Export utility functions
  Crossfilter.bisectLeft = bisectLeft;
  Crossfilter.bisectRight = bisectRight;
  Crossfilter.permute = function(array, indexes) {
    return indexes.map(function(i) { return array[i]; });
  };

  // Main factory function
  function crossfilter(data) {
    return new Crossfilter(data);
  }

  // Attach version
  crossfilter.version = '1.5.4-minimal';

  // Export
  return crossfilter;
}));

// Make available globally if not using modules
if (typeof window !== 'undefined' && !window.crossfilter) {
  window.crossfilter = window.crossfilter || (typeof module !== 'undefined' ? module.exports : null);
}