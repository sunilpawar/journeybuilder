/**
 * Fabric.js Library (Minimal Build for Journey Builder)
 * This is a minimal implementation for canvas manipulation and drag-and-drop
 * For production use, include the full fabric.min.js from http://fabricjs.com/
 */

(function(global) {
  'use strict';

  var fabric = {};

  // Utility functions
  function extend(destination, source) {
    for (var property in source) {
      destination[property] = source[property];
    }
    return destination;
  }

  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // Point class
  fabric.Point = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  };

  fabric.Point.prototype = {
    add: function(that) {
      return new fabric.Point(this.x + that.x, this.y + that.y);
    },
    subtract: function(that) {
      return new fabric.Point(this.x - that.x, this.y - that.y);
    },
    distance: function(that) {
      var dx = this.x - that.x;
      var dy = this.y - that.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  };

  // Object base class
  fabric.Object = function(options) {
    options = options || {};
    
    this.left = options.left || 0;
    this.top = options.top || 0;
    this.width = options.width || 100;
    this.height = options.height || 100;
    this.fill = options.fill || 'transparent';
    this.stroke = options.stroke || null;
    this.strokeWidth = options.strokeWidth || 1;
    this.opacity = options.opacity || 1;
    this.visible = options.visible !== false;
    this.selectable = options.selectable !== false;
    this.evented = options.evented !== false;
    this.angle = options.angle || 0;
    this.scaleX = options.scaleX || 1;
    this.scaleY = options.scaleY || 1;
    this.originX = options.originX || 'left';
    this.originY = options.originY || 'top';
    
    this._eventListeners = {};
  };

  fabric.Object.prototype = {
    set: function(key, value) {
      if (typeof key === 'object') {
        for (var prop in key) {
          this.set(prop, key[prop]);
        }
      } else {
        this[key] = value;
      }
      return this;
    },

    get: function(property) {
      return this[property];
    },

    animate: function(property, endValue, options) {
      options = options || {};
      var duration = options.duration || 500;
      var startValue = this.get(property);
      var startTime = Date.now();
      var self = this;

      function update() {
        var elapsed = Date.now() - startTime;
        var progress = Math.min(elapsed / duration, 1);
        
        var currentValue = startValue + (endValue - startValue) * progress;
        self.set(property, currentValue);
        
        if (self.canvas) {
          self.canvas.renderAll();
        }

        if (progress < 1) {
          requestAnimationFrame(update);
        } else if (options.onComplete) {
          options.onComplete();
        }
      }

      requestAnimationFrame(update);
      return this;
    },

    on: function(eventName, handler) {
      if (!this._eventListeners[eventName]) {
        this._eventListeners[eventName] = [];
      }
      this._eventListeners[eventName].push(handler);
      return this;
    },

    off: function(eventName, handler) {
      if (!this._eventListeners[eventName]) return this;
      
      if (handler) {
        var index = this._eventListeners[eventName].indexOf(handler);
        if (index > -1) {
          this._eventListeners[eventName].splice(index, 1);
        }
      } else {
        this._eventListeners[eventName] = [];
      }
      return this;
    },

    fire: function(eventName, options) {
      if (!this._eventListeners[eventName]) return this;
      
      options = options || {};
      options.target = this;
      
      this._eventListeners[eventName].forEach(function(handler) {
        handler(options);
      });
      return this;
    },

    getBoundingRect: function() {
      return {
        left: this.left,
        top: this.top,
        width: this.width * this.scaleX,
        height: this.height * this.scaleY
      };
    },

    intersectsWithObject: function(other) {
      var rect1 = this.getBoundingRect();
      var rect2 = other.getBoundingRect();
      
      return !(rect1.left > rect2.left + rect2.width ||
               rect2.left > rect1.left + rect1.width ||
               rect1.top > rect2.top + rect2.height ||
               rect2.top > rect1.top + rect1.height);
    }
  };

  // Rectangle class
  fabric.Rect = function(options) {
    fabric.Object.call(this, options);
    this.type = 'rect';
  };

  fabric.Rect.prototype = Object.create(fabric.Object.prototype);
  fabric.Rect.prototype.constructor = fabric.Rect;

  fabric.Rect.prototype._render = function(ctx) {
    ctx.fillStyle = this.fill;
    ctx.strokeStyle = this.stroke;
    ctx.lineWidth = this.strokeWidth;
    
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    if (this.stroke) {
      ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
    }
  };

  // Circle class
  fabric.Circle = function(options) {
    fabric.Object.call(this, options);
    this.type = 'circle';
    this.radius = options.radius || 50;
  };

  fabric.Circle.prototype = Object.create(fabric.Object.prototype);
  fabric.Circle.prototype.constructor = fabric.Circle;

  fabric.Circle.prototype._render = function(ctx) {
    ctx.beginPath();
    ctx.arc(0, 0, this.radius, 0, 2 * Math.PI);
    
    if (this.fill) {
      ctx.fillStyle = this.fill;
      ctx.fill();
    }
    
    if (this.stroke) {
      ctx.strokeStyle = this.stroke;
      ctx.lineWidth = this.strokeWidth;
      ctx.stroke();
    }
  };

  // Text class
  fabric.Text = function(text, options) {
    fabric.Object.call(this, options);
    this.type = 'text';
    this.text = text || '';
    this.fontSize = options.fontSize || 16;
    this.fontFamily = options.fontFamily || 'Arial';
    this.fontWeight = options.fontWeight || 'normal';
    this.textAlign = options.textAlign || 'left';
  };

  fabric.Text.prototype = Object.create(fabric.Object.prototype);
  fabric.Text.prototype.constructor = fabric.Text;

  fabric.Text.prototype._render = function(ctx) {
    ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;
    ctx.textAlign = this.textAlign;
    ctx.fillStyle = this.fill;
    
    var lines = this.text.split('\n');
    var lineHeight = this.fontSize * 1.2;
    
    for (var i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], 0, i * lineHeight);
    }
  };

  // Group class
  fabric.Group = function(objects, options) {
    fabric.Object.call(this, options);
    this.type = 'group';
    this.objects = objects || [];
  };

  fabric.Group.prototype = Object.create(fabric.Object.prototype);
  fabric.Group.prototype.constructor = fabric.Group;

  fabric.Group.prototype.add = function(object) {
    this.objects.push(object);
    object.group = this;
    return this;
  };

  fabric.Group.prototype.remove = function(object) {
    var index = this.objects.indexOf(object);
    if (index > -1) {
      this.objects.splice(index, 1);
      object.group = null;
    }
    return this;
  };

  fabric.Group.prototype._render = function(ctx) {
    for (var i = 0; i < this.objects.length; i++) {
      var obj = this.objects[i];
      if (obj.visible && obj._render) {
        ctx.save();
        ctx.translate(obj.left, obj.top);
        ctx.rotate(obj.angle * Math.PI / 180);
        ctx.scale(obj.scaleX, obj.scaleY);
        ctx.globalAlpha = obj.opacity;
        obj._render(ctx);
        ctx.restore();
      }
    }
  };

  // Canvas class
  fabric.Canvas = function(element, options) {
    options = options || {};
    
    this.lowerCanvasEl = typeof element === 'string' ? 
      document.getElementById(element) : element;
    this.contextContainer = this.lowerCanvasEl.getContext('2d');
    
    this.width = options.width || this.lowerCanvasEl.width || 800;
    this.height = options.height || this.lowerCanvasEl.height || 600;
    
    this.lowerCanvasEl.width = this.width;
    this.lowerCanvasEl.height = this.height;
    
    this._objects = [];
    this._activeObject = null;
    this._eventListeners = {};
    this._isCurrentlyDrawing = false;
    
    this._initEventListeners();
  };

  fabric.Canvas.prototype = {
    add: function(object) {
      this._objects.push(object);
      object.canvas = this;
      this.renderAll();
      return this;
    },

    remove: function(object) {
      var index = this._objects.indexOf(object);
      if (index > -1) {
        this._objects.splice(index, 1);
        object.canvas = null;
        if (this._activeObject === object) {
          this._activeObject = null;
        }
        this.renderAll();
      }
      return this;
    },

    clear: function() {
      this._objects = [];
      this._activeObject = null;
      this.renderAll();
      return this;
    },

    renderAll: function() {
      var ctx = this.contextContainer;
      ctx.clearRect(0, 0, this.width, this.height);
      
      for (var i = 0; i < this._objects.length; i++) {
        var obj = this._objects[i];
        if (obj.visible && obj._render) {
          ctx.save();
          ctx.translate(obj.left + obj.width/2, obj.top + obj.height/2);
          ctx.rotate(obj.angle * Math.PI / 180);
          ctx.scale(obj.scaleX, obj.scaleY);
          ctx.globalAlpha = obj.opacity;
          obj._render(ctx);
          ctx.restore();
        }
      }
      
      return this;
    },

    getObjects: function() {
      return this._objects.slice();
    },

    getActiveObject: function() {
      return this._activeObject;
    },

    setActiveObject: function(object) {
      this._activeObject = object;
      this.renderAll();
      return this;
    },

    discardActiveObject: function() {
      this._activeObject = null;
      this.renderAll();
      return this;
    },

    findTarget: function(pointer) {
      for (var i = this._objects.length - 1; i >= 0; i--) {
        var obj = this._objects[i];
        if (obj.selectable && this._containsPoint(obj, pointer)) {
          return obj;
        }
      }
      return null;
    },

    _containsPoint: function(object, point) {
      var rect = object.getBoundingRect();
      return point.x >= rect.left && 
             point.x <= rect.left + rect.width &&
             point.y >= rect.top && 
             point.y <= rect.top + rect.height;
    },

    _initEventListeners: function() {
      var self = this;
      
      this.lowerCanvasEl.addEventListener('mousedown', function(e) {
        self._onMouseDown(e);
      });
      
      this.lowerCanvasEl.addEventListener('mousemove', function(e) {
        self._onMouseMove(e);
      });
      
      this.lowerCanvasEl.addEventListener('mouseup', function(e) {
        self._onMouseUp(e);
      });
    },

    _onMouseDown: function(e) {
      var pointer = this._getPointer(e);
      var target = this.findTarget(pointer);
      
      this.setActiveObject(target);
      this._isCurrentlyDrawing = true;
      
      if (target) {
        this._lastPointer = pointer;
        this.fire('mouse:down', {
          target: target,
          pointer: pointer,
          e: e
        });
      }
    },

    _onMouseMove: function(e) {
      var pointer = this._getPointer(e);
      
      if (this._isCurrentlyDrawing && this._activeObject && this._lastPointer) {
        var deltaX = pointer.x - this._lastPointer.x;
        var deltaY = pointer.y - this._lastPointer.y;
        
        this._activeObject.left += deltaX;
        this._activeObject.top += deltaY;
        
        this._lastPointer = pointer;
        this.renderAll();
        
        this.fire('object:moving', {
          target: this._activeObject,
          pointer: pointer,
          e: e
        });
      }
    },

    _onMouseUp: function(e) {
      this._isCurrentlyDrawing = false;
      this._lastPointer = null;
      
      if (this._activeObject) {
        this.fire('mouse:up', {
          target: this._activeObject,
          pointer: this._getPointer(e),
          e: e
        });
      }
    },

    _getPointer: function(e) {
      var rect = this.lowerCanvasEl.getBoundingClientRect();
      return new fabric.Point(
        e.clientX - rect.left,
        e.clientY - rect.top
      );
    },

    on: function(eventName, handler) {
      if (!this._eventListeners[eventName]) {
        this._eventListeners[eventName] = [];
      }
      this._eventListeners[eventName].push(handler);
      return this;
    },

    off: function(eventName, handler) {
      if (!this._eventListeners[eventName]) return this;
      
      if (handler) {
        var index = this._eventListeners[eventName].indexOf(handler);
        if (index > -1) {
          this._eventListeners[eventName].splice(index, 1);
        }
      } else {
        this._eventListeners[eventName] = [];
      }
      return this;
    },

    fire: function(eventName, options) {
      if (!this._eventListeners[eventName]) return this;
      
      options = options || {};
      options.target = options.target || this;
      
      this._eventListeners[eventName].forEach(function(handler) {
        handler(options);
      });
      return this;
    },

    toJSON: function() {
      return {
        version: fabric.version,
        objects: this._objects.map(function(obj) {
          return obj.toObject ? obj.toObject() : obj;
        })
      };
    },

    loadFromJSON: function(json, callback) {
      var data = typeof json === 'string' ? JSON.parse(json) : json;
      var self = this;
      
      this.clear();
      
      if (data.objects) {
        data.objects.forEach(function(objData) {
          var obj = fabric.util.createObjectFromData(objData);
          if (obj) {
            self.add(obj);
          }
        });
      }
      
      if (callback) {
        callback();
      }
      
      return this;
    }
  };

  // Static Canvas (non-interactive)
  fabric.StaticCanvas = function(element, options) {
    fabric.Canvas.call(this, element, options);
  };

  fabric.StaticCanvas.prototype = Object.create(fabric.Canvas.prototype);
  fabric.StaticCanvas.prototype.constructor = fabric.StaticCanvas;

  // Remove interactive methods for StaticCanvas
  fabric.StaticCanvas.prototype._initEventListeners = function() {};
  fabric.StaticCanvas.prototype.setActiveObject = function() { return this; };
  fabric.StaticCanvas.prototype.discardActiveObject = function() { return this; };

  // Utility functions
  fabric.util = {
    createObjectFromData: function(data) {
      switch (data.type) {
        case 'rect':
          return new fabric.Rect(data);
        case 'circle':
          return new fabric.Circle(data);
        case 'text':
          return new fabric.Text(data.text, data);
        case 'group':
          var objects = data.objects ? data.objects.map(fabric.util.createObjectFromData) : [];
          return new fabric.Group(objects, data);
        default:
          return null;
      }
    },

    animate: function(object, property, endValue, options) {
      return object.animate(property, endValue, options);
    },

    loadImage: function(url, callback) {
      var img = new Image();
      img.onload = function() {
        callback(img);
      };
      img.onerror = function() {
        callback(null, new Error('Failed to load image: ' + url));
      };
      img.src = url;
    }
  };

  // Color utilities
  fabric.Color = function(color) {
    this._source = color;
  };

  fabric.Color.prototype = {
    toRgb: function() {
      return this._source;
    },
    
    toHex: function() {
      return this._source;
    }
  };

  // Image class
  fabric.Image = function(element, options) {
    fabric.Object.call(this, options);
    this.type = 'image';
    this._element = element;
  };

  fabric.Image.prototype = Object.create(fabric.Object.prototype);
  fabric.Image.prototype.constructor = fabric.Image;

  fabric.Image.prototype._render = function(ctx) {
    if (this._element) {
      ctx.drawImage(this._element, -this.width/2, -this.height/2, this.width, this.height);
    }
  };

  fabric.Image.fromURL = function(url, callback, imgOptions) {
    fabric.util.loadImage(url, function(img, error) {
      if (error) {
        callback(null, error);
      } else {
        var fabricImg = new fabric.Image(img, imgOptions);
        fabricImg.width = img.width;
        fabricImg.height = img.height;
        callback(fabricImg);
      }
    });
  };

  // Version
  fabric.version = '5.3.0-minimal';

  // Export
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = fabric;
    }
    exports.fabric = fabric;
  } else if (typeof define === 'function' && define.amd) {
    define([], function() {
      return fabric;
    });
  } else {
    global.fabric = fabric;
  }

})(typeof window !== 'undefined' ? window : this);